#include "hsp3dish.as"
#include "hspmath.as"

doublePointFlag = 0
wsize = absf(ginfo(12))*2
hsize = absf(ginfo(13))*2
;buffer 2,wsize,hsize
buffer 1
//1:元のjpg画像
celload "map.png",1
screen 0
rate = 1.0
prevRate = 1.0
X = absf(ginfo(12)/2)
Y = absf(ginfo(13)/2)
prevX = 0.0
prevY = 0.0
moveFirstX = 0.0
moveFirstY = 0.0
prevCenterX = 0.0
prevCenterY = 0.0
moveFirstTheta = 0.0

systemRate = 1.0
repeat
	redraw 0
	pos 0,0	
	color 255,255,255
	mtlist touchid
	num=stat
	repeat num
		id = touchid(cnt)
		mtinfo touch,id
//		mes "T:"+id+"("+touch(1)+","+touch(2)+") "+touch(3)
	loop
	if num=1:gosub*singlePoint:else:singlePointFlag = 0
	if num=2:gosub*doublePoint:else:doublePointFlag = 0

//倍率を合わせる
	;pos 0,0
	;gzoom wsize,hsize,1,X-((wsize/rate)/2),Y-((hsize/rate)/2),(wsize/rate),(hsize/rate),0

	

//回転をする
	
	title "x:"+x+",y:"+y+""
	gmode 0,(wsize/rate)*2*systemRate,(hsize/rate)*2*systemRate//コピー元の大きさ
	pos ((wsize/rate)*systemRate),((hsize/rate)*systemRate)
	grotate 1,X-((wsize/rate)*systemRate),Y-((hsize/rate)*systemRate),0.0,wsize*2*systemRate,hsize*2*systemRate//コピー先の大きさ
	boxf ((wsize/rate)*systemRate)-5,((hsize/rate)*systemRate)-5,((wsize/rate)*systemRate)+5,((hsize/rate)*systemRate)+5

	/*
	gmode 0,(wsize/rate),(hsize/rate)//コピー元の大きさ
	pos X,Y
	grotate 1,X-((wsize/rate)/2),Y-((hsize/rate)/2),theta,wsize,hsize//コピー先の大きさ
	*/
	redraw 1
	await 1000/60

loop

stop

*singlePoint
	id = touchid(0)
	mtinfo touch,id
	_X = absf( touch(1) )
	_Y = absf( touch(2) )
	if singlePointFlag = 0{
		moveFirstX = _X
		moveFirstY = _Y
		singlePointFlag = 1
		prevX = X
		prevY = Y
	}else{
		//比率に合わせて移動量も
		X = prevX + ( _X - moveFirstX )//rate
		Y = prevY + ( _Y - moveFirstY )//rate
	}
return

*doublePoint
	//2つの点を取得
	id0 = touchid(0)
	id1 = touchid(1)
	mtinfo touch0,id0
	mtinfo touch1,id1
	dim point0 ,2
	point0(0) = touch0(1)
	point0(1) = touch0(2)
	
	dim point1 ,2
	point1(0) = touch1(1)
	point1(1) = touch1(2)
	
	centerX = absf( touch0(1) + touch1(1) )/2
	centerY = absf( touch0(2) + touch1(2) )/2

	

	if doublePointFlag == 0 {
		doublePointFlag = distance2(point0,point1)
		prevRate = rate
		prevCenterX = centerX
		prevCenterY = centerY
		moveFirstTheta = atan(touch0(1) - touch1(1),touch0(2) - touch1(2))
		prevTheta = theta
	}else{
		rate = limitf(absf( prevRate * distance2(point0,point1)/doublePointFlag ),0.5,2.0)
		centerX += prevCenterX 
		centerY += prevCenterY
		theta = moveFirstTheta - atan(touch0(1) - touch1(1),touch0(2) - touch1(2)) + prevTheta
	}

return